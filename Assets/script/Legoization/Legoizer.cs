//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.IO;
using UnityEngine.UI;


namespace AssemblyCSharp
{
	public class Legoizer:MonoBehaviour
	{
		public Transform Canvas;
		public Transform LoadingBar;
		public Transform percentText;
		public Transform LoadingText;
		private bool onLoading = false;
		private float percentage;

		List<Lego> legos;
		private Dictionary<ColorSpecification,List<Lego>>legosCoordinate;
		private LegoBuffer buffer;
		private Vector3 legoGridDimen;
		private Grid[,,] grids;
		private Lego[,,] legoGrid;
		private bool inLegoize = false;

		public Legoizer ()
		{
		}

		public void FixedUpdate(){
			if (!inLegoize)
				return;
			//Update GUI
			if (onLoading) {
				// Legoization...
				//update GUI initialize loading bar
				if (percentage < 1) {
					//Update the loading percentage(text part)
					percentText.GetComponent<Text> ().text = String.Format("{0:0.00}",percentage*100) + "%";
					LoadingText.gameObject.SetActive (true);
				} else {
					//update UI when the process is done
					LoadingText.gameObject.SetActive (true);
					percentText.GetComponent<Text> ().text = "DONE!";
				}
				//set the loading bar to active
				Canvas.gameObject.SetActive (true);
				//Update the loading percentage(Graphic part)
				LoadingBar.GetComponent<Image> ().fillAmount = percentage;
			} else {
				//no voxelizing... turn the loading bar to invisible
				Canvas.gameObject.SetActive (false);
			}
			
		}

		private int numOfLegoConnected(List<Lego> curs){
			int counter = 0;
			foreach (Lego cur in curs) {
				foreach (Vector3 fpos in cur.up)
					legoGrid [(int)fpos.x, (int)fpos.y, (int)fpos.z].isVisted = false;
				foreach (Vector3 fpos in cur.down)
					legoGrid [(int)fpos.x, (int)fpos.y, (int)fpos.z].isVisted = false;
			}
			foreach (Lego cur in curs) {
				foreach (Vector3 fpos in cur.up) {
					if(!legoGrid [(int)fpos.x, (int)fpos.y, (int)fpos.z].isVisted){
						counter++;
					}
				}
				foreach (Vector3 fpos in cur.down) {
					if(!legoGrid [(int)fpos.x, (int)fpos.y, (int)fpos.z].isVisted){
						counter++;
					}
				}
			}
			return counter;
		}

		private void resetLego(Vector3 gpos){
			List<Vector3> vectorList = new List<Vector3> ();
			vectorList.AddRange(legoGrid[(int)gpos.x,(int)gpos.y,(int)gpos.z].gposList);
			foreach (Vector3 pos in vectorList) {
				int x = (int)pos.x;
				int y = (int)pos.y;
				int z = (int)pos.z;
				legoGrid[x,y,z] = new Lego(grids[x,y,z].nearestColor(),grids[x,y,z].getPosition(),LegoType.PLATE,grids[x,y,z].isBound);
				legoGrid[x,y,z].setGPos(new Vector3(x,y,z));
				legoGrid[x,y,z].gposList.Add(new Vector3(x,y,z));
			}

			foreach (Vector3 pos in vectorList) {
				int x = (int)pos.x;
				int y = (int)pos.y;
				int z = (int)pos.z;
				if (x - 1 >= 0 && legoGrid [x - 1, y, z] != null)
					legoGrid [x, y, z].left.Add (new Vector3(x - 1, y, z));
				if (x + 1 < legoGridDimen.x && legoGrid [x + 1, y, z] != null)
					legoGrid [x, y, z].right.Add (new Vector3(x + 1, y, z));
			
				if (y + 1 < legoGridDimen.y && legoGrid [x, y + 1, z] != null)
					legoGrid [x, y, z].up.Add (new Vector3(x, y + 1, z));
				if (y - 1 >= 0 && legoGrid [x, y - 1, z] != null)
					legoGrid [x, y, z].down.Add (new Vector3(x, y - 1, z));
			
				if (z + 1 < legoGridDimen.z && legoGrid [x, y, z + 1] != null)
					legoGrid [x, y, z].back.Add (new Vector3(x, y, z + 1));
				if (z - 1 >= 0 && legoGrid [x, y, z - 1] != null)
					legoGrid [x, y, z].front.Add (new Vector3(x, y, z - 1));
			}
			vectorList.Clear();
		}

		private bool isValidLego(Vector2 LegoA, Vector2 LegoB, bool isHorizontal){
			if (isHorizontal) {
				if (LegoA.y != LegoB.y) {
					return false;
				} else if (LegoA.y > 2) {
					if(LegoA.x + LegoB.x != 2)
						return false;
					else
						return true;
				} else {
					switch ((int)(LegoA.x + LegoB.x)) {
					case 1:	case 2:	case 3:	case 4:	case 6:	case 8:
						return true;
					default:
						return false;
					}
				}
			} else {
				if (LegoA.x != LegoB.x) {
					return false;
				} else if (LegoA.x > 2) {
					if(LegoA.y + LegoB.y != 2)
						return false;
					else
						return true;
				} else {
					switch ((int)(LegoA.y + LegoB.y)) {
					case 1: case 2: case 3:	case 4:	case 6:	case 8:
						return true;
					default:
						return false;
					}
				}
			}
		}

		private bool isValidLego(Vector2 LegoA, Vector2 LegoB, Vector2 LegoC, bool isHorizontal){
			if (isHorizontal) {
				if (LegoA.y != LegoB.y || LegoA.y != LegoC.y) {
					return false;
				} else if (LegoA.y > 2) {
					return false;
				} else {
					switch ((int)(LegoA.x + LegoB.x + LegoC.x)) {
					case 1:	case 2:	case 3:	case 4:	case 6:	case 8:
						return true;
					default:
						return false;
					}
				}
			} else {
				if (LegoA.x != LegoB.x || LegoA.x != LegoC.x) {
					return false;
				} else if (LegoA.x > 2) {
					return false;
				} else {
					switch ((int)(LegoA.y + LegoB.y + LegoC.y)) {
					case 1: case 2: case 3:	case 4:	case 6:	case 8:
						return true;
					default:
						return false;
					}
				}
			}
		}

		private void mergeTwoLegoVert(Vector3 frontLegoPos, Vector3 backLegoPos){
			Lego frontLego = legoGrid [(int)frontLegoPos.x, (int)frontLegoPos.y, (int)frontLegoPos.z];
			Lego backLego = legoGrid [(int)backLegoPos.x, (int)backLegoPos.y, (int)backLegoPos.z];

			if (frontLego.getGPosition ().z > backLego.getGPosition ().z) {
				Lego tempLego = frontLego;
				frontLego = backLego;
				backLego = tempLego;
			}

			if(Vector3.Distance(frontLego.getGPosition(),backLego.getGPosition())-(int)Vector3.Distance(frontLego.getGPosition(),backLego.getGPosition()) != 0){
				Debug.Log(Vector3.Distance(frontLego.getGPosition(),backLego.getGPosition()));
				Debug.Log(frontLego.getGPosition());
				Debug.Log(frontLego.getType());
				Debug.Log(backLego.getGPosition());
				Debug.Log(backLego.getType());
			}

			Vector2 dimen = new Vector2(frontLego.getDimen().x , frontLego.getDimen().y+backLego.getDimen().y);
			frontLego.gposList.AddRange (backLego.gposList);
			
			List<Vector3> up = new List<Vector3>();
			up.AddRange(frontLego.up);
			up.AddRange(backLego.up);
			
			List<Vector3> down = new List<Vector3>();
			down.AddRange(frontLego.down);
			down.AddRange(backLego.down);
				
			List<Vector3> left = new List<Vector3>();
			left.AddRange(backLego.left);
			left.AddRange(frontLego.left);
				
			List<Vector3> right = new List<Vector3>();
			right.AddRange(frontLego.right);
			right.AddRange(backLego.right);
				
			List<Vector3> front = new List<Vector3>();
			front.AddRange(frontLego.front);
				
			List<Vector3> back = new List<Vector3>();
			back.AddRange(backLego.back);
				
			Vector3 pos = (frontLego.getPosition()*frontLego.getDimen().y + backLego.getPosition()*backLego.getDimen().y)/(frontLego.getDimen().y+backLego.getDimen().y);
			
			frontLego.addNeighborLego (up,down,left,right,front,back);
			frontLego.setPosition (pos);
			frontLego.changeDimen (dimen);

			Lego result = frontLego;

			if (backLego.isBound)
				result.isBound = true;

			foreach (Vector3 gpo in frontLego.gposList) {
				legoGrid[(int)gpo.x,(int)gpo.y,(int)gpo.z] = result;
			}
		}

		private void mergeTwoLegoHor(Vector3 leftLegoPos, Vector3 rightLegoPos){
			Lego leftLego;
			Lego rightLego;
			if (leftLegoPos.x < rightLegoPos.x) {
				leftLego = legoGrid [(int)leftLegoPos.x, (int)leftLegoPos.y, (int)leftLegoPos.z];
				rightLego = legoGrid [(int)rightLegoPos.x, (int)rightLegoPos.y, (int)rightLegoPos.z];
			} else {
				leftLego = legoGrid [(int)rightLegoPos.x, (int)rightLegoPos.y, (int)rightLegoPos.z];
				rightLego = legoGrid [(int)leftLegoPos.x, (int)leftLegoPos.y, (int)leftLegoPos.z];
			}
			if(Vector3.Distance(leftLego.getGPosition(),rightLego.getGPosition())-(int)Vector3.Distance(leftLego.getGPosition(),rightLego.getGPosition()) != 0){
				Debug.Log(Vector3.Distance(leftLego.getGPosition(),rightLego.getGPosition()));
				Debug.Log(leftLego.getGPosition());
				Debug.Log(leftLego.getType());
				Debug.Log(rightLego.getGPosition());
				Debug.Log(rightLego.getType());
			}
			Vector2 dimen = new Vector2(leftLego.getDimen().x+rightLego.getDimen().x, leftLego.getDimen().y);
			leftLego.gposList.AddRange (rightLego.gposList);
			
			List<Vector3> up = new List<Vector3>();
			up.AddRange(leftLego.up);
			up.AddRange(rightLego.up);
			
			List<Vector3> down = new List<Vector3>();
			down.AddRange(leftLego.down);
			down.AddRange(rightLego.down);
			
			List<Vector3> left = leftLego.left;
			
			List<Vector3> right = rightLego.right;
			
			List<Vector3> front = new List<Vector3>();
			front.AddRange(leftLego.front);
			front.AddRange(rightLego.front);
			
			List<Vector3> back = new List<Vector3>();
			back.AddRange(leftLego.back);
			back.AddRange (rightLego.back);
			
			Vector3 pos = (rightLego.getPosition()*rightLego.getDimen().x+leftLego.getPosition()*leftLego.getDimen().x)/(rightLego.getDimen().x+leftLego.getDimen().x);
			
			leftLego.addNeighborLego (up,down,left,right,front,back);
			leftLego.setPosition (pos);
			leftLego.changeDimen (dimen);
			
			Lego result = leftLego;

			if (rightLego.isBound)
				result.isBound = true;

			foreach (Vector3 gpo in leftLego.gposList) {
				legoGrid[(int)gpo.x,(int)gpo.y,(int)gpo.z] = result;
			}
		}

		private void mergePlatesToBrick(ref Lego top, ref Lego cen, ref Lego bot){
			List<Vector3>up = top.up;
			List<Vector3>down = bot.down;

			cen.gposList.AddRange (top.gposList);
			cen.gposList.AddRange (bot.gposList);

			Vector3 gpos = bot.getGPosition ();

			List<Vector3>left = new List<Vector3>();
			left.AddRange(top.left);
			left.AddRange(cen.left);
			left.AddRange(bot.left);
			
			List<Vector3>right = new List<Vector3>();
			right.AddRange(top.right);
			right.AddRange(cen.right);
			right.AddRange(bot.right);
			
			List<Vector3>front = new List<Vector3>();
			front.AddRange(top.front);
			front.AddRange(cen.front);
			front.AddRange(bot.front);
			
			List<Vector3>back = new List<Vector3>();
			back.AddRange(top.back);
			back.AddRange(cen.back);
			back.AddRange(bot.back);
			
			cen.changeType(LegoType.BRCIK);
			cen.setGPos (gpos);
			cen.addNeighborLego(up,down,left,right,front,back);

			foreach (Vector3 gpo in cen.gposList) {
				legoGrid[(int)gpo.x,(int)gpo.y,(int)gpo.z] = cen;
			}

		}

		private bool mergeFront(Vector3 gpos){
			//back
			bool isSuccess = false;
			if (legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen ().x == 1) {	//change dimension checking
				if (legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].front.Count > 0) {	//change direction
					Vector3 ngpos = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].front [0];	//change direction
					if (legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getType () == legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getType () && 
					    legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getColor () == legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getColor ()) {
						//change dimension checking
						float resultDimen = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen ().y + legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getDimen ().y;
						if (resultDimen < 5.0f) {
							if (isValidLego (legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen (), legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getDimen (), false)) {
								//gpos	ngpos
								mergeTwoLegoVert(ngpos, gpos);	//change dimension
								isSuccess = true;
							}
						} else {
							if (legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].front.Count > 0) {	//change direction
								Vector3 nngpos = legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].front [0]; //change direction
								if (legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getType () == legoGrid [(int)nngpos.x, (int)nngpos.y, (int)nngpos.z].getType () && 
								    legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getColor () == legoGrid [(int)nngpos.x, (int)nngpos.y, (int)nngpos.z].getColor ()) {
									
									//change dimension checking
									if (isValidLego (legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen (), legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getDimen ()
									                 , legoGrid [(int)nngpos.x, (int)nngpos.y, (int)nngpos.z].getDimen (), false)){ 
										//gpos ngpos nngpos
										mergeTwoLegoVert (nngpos, ngpos);	//change dimension
										mergeTwoLegoVert (ngpos, gpos);	//change dimension
										isSuccess = true;
									}
								}
							}
						}
					}
				}
			} else if (legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen ().x == 2) { //change dimension checking
				bool keepgo = false;
				if (legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].front.Count > 0) {	//cahnge direction
					foreach (Vector3 ngposv in legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].front) {//cahnge direction
						if (legoGrid [(int)ngposv.x, (int)ngposv.y, (int)ngposv.z].isVisted)
							legoGrid [(int)ngposv.x, (int)ngposv.y, (int)ngposv.z].isVisted = false;
					}
					List<Vector3> uniGPos = new List<Vector3> ();
					foreach (Vector3 ngposv in legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].front) { //cahnge direction
						if (!legoGrid [(int)ngposv.x, (int)ngposv.y, (int)ngposv.z].isVisted) {
							legoGrid [(int)ngposv.x, (int)ngposv.y, (int)ngposv.z].isVisted = true;
							uniGPos.Add (legoGrid [(int)ngposv.x, (int)ngposv.y, (int)ngposv.z].getGPosition());
						}
					}
					
					if (uniGPos.Count == 1) {
						bool sameType =	legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getType () == legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getType ();
						bool sameColor = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getColor () == legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getColor ();
						//change dimension checking
						bool sameAxis = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getGPosition().x == legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getGPosition().x;
						//change dimension checking
						bool sameDimen = legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen().x == 2;
						if(sameType && sameColor && sameAxis && sameDimen){
							//change dimension checking
							float resultDimen = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen ().y + legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen ().y;
							if (resultDimen < 5.0f || resultDimen == 6.0f || resultDimen == 8.0f) {
								//change dimension checking
								if (isValidLego (legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen (), legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen (), false)) {
									//gpos	ngpos
									mergeTwoLegoVert (uniGPos[0], gpos);	//change dimension
									isSuccess = true;
								}
							}else if(resultDimen == 7.0f || resultDimen == 5.0f){
								keepgo = true;
							}
						}
					}else if (uniGPos.Count == 2) {
						if (uniGPos [0].x > uniGPos [1].x) {	//change dimension
							Vector3 temp = uniGPos [0];
							uniGPos [0] = uniGPos [1];
							uniGPos [1] = temp;
						}
						bool sameType = legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getType () == legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getType () &&
							legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getType () == legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getType ();
						
						bool sameColor = legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getColor () == legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getColor () &&
							legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getColor () == legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getColor ();
						
						bool sameDimen = legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen().x == 1 &&
							legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getDimen ().x == 1 &&
								legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen().y == legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getDimen ().y;
						
						if (sameColor && sameType && sameDimen) {
							if (isValidLego (legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen (),
							                 legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getDimen (), true)) { //change dimension
								mergeTwoLegoHor (uniGPos [0], uniGPos [1]); //change dimension
								float resultDimen = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen ().y + legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getDimen ().y;
								if (resultDimen < 5.0f || resultDimen == 6.0f || resultDimen == 8.0f) {
									if (isValidLego (legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen (),
									                 legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen (), false)) {//change dimension
										mergeTwoLegoVert (uniGPos [0], gpos); //change dimension
										isSuccess = true;
									}
								}else if(resultDimen == 7.0f || resultDimen == 5.0f){
									keepgo = true;
								}
							}
						}
					}
					
					if(!isSuccess && keepgo){
						Vector3 ngpos = uniGPos[0];
						if (legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].front.Count > 0) {	//change direction
							foreach (Vector3 nngpos in legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].front) { //change direction
								if (legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].isVisted)
									legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].isVisted = false;
							}
							uniGPos.Clear();
							foreach (Vector3 nngpos in legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].front) { //change direction
								if (!legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].isVisted) {
									legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].isVisted = true;
									uniGPos.Add (new Vector3 (ngpos.x,ngpos.y,ngpos.z));
								}
							}
							
							if (uniGPos.Count == 1) {
								bool sameType =	legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getType () == legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getType ();
								bool sameColor = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getColor () == legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getColor ();
								//change dimension checking
								bool sameAxis = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getGPosition().x == legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getGPosition().x;
								bool sameDimen = legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen().x == 2; //change dimension checking
								if(sameType && sameColor && sameAxis && sameDimen){
									if (isValidLego (legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen (), legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen (), false)) {
										//gpos	ngpos
										mergeTwoLegoVert(uniGPos[0], ngpos); //change dimension
										mergeTwoLegoVert(ngpos, gpos); //change dimension
										isSuccess = true;
									}
								}
							}else if(uniGPos.Count == 2){
								if (uniGPos [0].x > uniGPos [1].x) {	//change dimension
									Vector3 temp = uniGPos [0];
									uniGPos [0] = uniGPos [1];
									uniGPos [1] = temp;
								}
								
								bool sameType = legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getType () == legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getType () &&
									legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getType () == legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getType ();
								
								bool sameColor = legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getColor () == legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getColor () &&
									legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getColor () == legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getColor ();
								
								bool sameDimen = legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen().x == 1 &&
									legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getDimen ().x == 1 &&
										legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen().y == legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getDimen ().y;
								
								if (sameColor && sameType && sameDimen) {
									if (isValidLego (legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen (),
									                 legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getDimen (), true)) {//change dimension
										mergeTwoLegoHor (uniGPos [0], uniGPos [1]); //change dimension
										if (isValidLego (legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen (),
										                 legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getDimen (),
										                 legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen (), false)) {//change dimension
											mergeTwoLegoVert (uniGPos [0], ngpos); //change dimension
											mergeTwoLegoVert (ngpos, gpos); //change dimension
											isSuccess = true;
										}
									}
								}
							}
							
						}
					}
				}
			} else {
				if (legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].front.Count > 0) {	//change dimension
					Vector3 ngpos = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].front [0];	//change dimension
					if (legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getType () == legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getType () && 
					    legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getColor () == legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getColor ()) {
						//change dimension
						bool sameAxis = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getGPosition().x == legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getGPosition().x;
						//change dimension
						float resultDimen = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen ().y + legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getDimen ().y;
						if (resultDimen == 2.0f && sameAxis) {
							//change dimension
							if (isValidLego (legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen (), legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getDimen (), false)) {
								//gpos	ngpos
								mergeTwoLegoVert (ngpos, gpos); //change dimension
								isSuccess = true;
							}
						}
					}
				}
				
			}
			return isSuccess;
		}

		private bool mergeBack(Vector3 gpos){
			//back
			bool isSuccess = false;
			if (legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen ().x == 1) {	//change dimension checking
				if (legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].back.Count > 0) {	//change direction
					Vector3 ngpos = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].back [0];	//change direction
					if (legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getType () == legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getType () && 
					    legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getColor () == legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getColor ()) {
						//change dimension checking
						float resultDimen = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen ().y + legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getDimen ().y;
						if (resultDimen < 5.0f) {
							if (isValidLego (legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen (), legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getDimen (), false)) {
								//gpos	ngpos
								mergeTwoLegoVert(gpos, ngpos);	//change dimension
								isSuccess = true;
							}
						} else {
							if (legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].back.Count > 0) {	//change direction
								Vector3 nngpos = legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].back [0]; //change direction
								if (legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getType () == legoGrid [(int)nngpos.x, (int)nngpos.y, (int)nngpos.z].getType () && 
								    legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getColor () == legoGrid [(int)nngpos.x, (int)nngpos.y, (int)nngpos.z].getColor ()) {

									//change dimension checking
									if (isValidLego (legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen (), legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getDimen ()
									                 , legoGrid [(int)nngpos.x, (int)nngpos.y, (int)nngpos.z].getDimen (), false)){ 
										//gpos ngpos nngpos
										mergeTwoLegoVert (gpos, ngpos);	//change dimension
										mergeTwoLegoVert (gpos, nngpos);	//change dimension
										isSuccess = true;
									}
								}
							}
						}
					}
				}
			} else if (legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen ().x == 2) { //change dimension checking
				bool keepgo = false;
				if (legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].back.Count > 0) {	//cahnge direction
					foreach (Vector3 ngposv in legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].back) {//cahnge direction
						if (legoGrid [(int)ngposv.x, (int)ngposv.y, (int)ngposv.z].isVisted)
							legoGrid [(int)ngposv.x, (int)ngposv.y, (int)ngposv.z].isVisted = false;
					}
					List<Vector3> uniGPos = new List<Vector3> ();
					foreach (Vector3 ngposv in legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].back) { //cahnge direction
						if (!legoGrid [(int)ngposv.x, (int)ngposv.y, (int)ngposv.z].isVisted) {
							legoGrid [(int)ngposv.x, (int)ngposv.y, (int)ngposv.z].isVisted = true;
							uniGPos.Add (legoGrid [(int)ngposv.x, (int)ngposv.y, (int)ngposv.z].getGPosition());
						}
					}
					
					if (uniGPos.Count == 1) {
						bool sameType =	legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getType () == legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getType ();
						bool sameColor = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getColor () == legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getColor ();
						//change dimension checking
						bool sameAxis = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getGPosition().x == legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getGPosition().x;
						//change dimension checking
						bool sameDimen = legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen().x == 2;
						if(sameType && sameColor && sameAxis && sameDimen){
							//change dimension checking
							float resultDimen = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen ().y + legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen ().y;
							if (resultDimen < 5.0f || resultDimen == 6.0f || resultDimen == 8.0f) {
								//change dimension checking
								if (isValidLego (legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen (), legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen (), false)) {
									//gpos	ngpos
									mergeTwoLegoVert (gpos, uniGPos[0]);	//change dimension
									isSuccess = true;
								}
							}else if(resultDimen == 7.0f || resultDimen == 5.0f){
								keepgo = true;
							}
						}
					}else if (uniGPos.Count == 2) {
						if (uniGPos [0].x > uniGPos [1].x) {	//change dimension
							Vector3 temp = uniGPos [0];
							uniGPos [0] = uniGPos [1];
							uniGPos [1] = temp;
						}
						bool sameType = legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getType () == legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getType () &&
							legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getType () == legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getType ();
						
						bool sameColor = legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getColor () == legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getColor () &&
							legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getColor () == legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getColor ();
						
						bool sameDimen = legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen().x == 1 &&
							legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getDimen ().x == 1 &&
								legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen().y == legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getDimen ().y;
						
						if (sameColor && sameType && sameDimen) {
							if (isValidLego (legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen (),
							                 legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getDimen (), true)) { //change dimension
								mergeTwoLegoHor (uniGPos [0], uniGPos [1]); //change dimension
								float resultDimen = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen ().y + legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getDimen ().y;
								if (resultDimen < 5.0f || resultDimen == 6.0f || resultDimen == 8.0f) {
									if (isValidLego (legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen (),
									                 legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen (), false)) {//change dimension
										mergeTwoLegoVert (gpos, uniGPos [0]); //change dimension
										isSuccess = true;
									}
								}else if(resultDimen == 7.0f || resultDimen == 5.0f){
									keepgo = true;
								}
							}
						}
					}
					
					if(!isSuccess && keepgo){
						Vector3 ngpos = uniGPos[0];
						if (legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].back.Count > 0) {	//change direction
							foreach (Vector3 nngpos in legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].back) { //change direction
								if (legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].isVisted)
									legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].isVisted = false;
							}
							uniGPos.Clear();
							foreach (Vector3 nngpos in legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].back) { //change direction
								if (!legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].isVisted) {
									legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].isVisted = true;
									uniGPos.Add (new Vector3 (ngpos.x,ngpos.y,ngpos.z));
								}
							}

							if (uniGPos.Count == 1) {
								bool sameType =	legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getType () == legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getType ();
								bool sameColor = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getColor () == legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getColor ();
								//change dimension checking
								bool sameAxis = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getGPosition().x == legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getGPosition().x;
								bool sameDimen = legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen().x == 2; //change dimension checking
								if(sameType && sameColor && sameAxis && sameDimen){
									if (isValidLego (legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen (), legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen (), false)) {
										//gpos	ngpos
										mergeTwoLegoVert(gpos, ngpos); //change dimension
										mergeTwoLegoVert(gpos, uniGPos[0]); //change dimension
										isSuccess = true;
									}
								}
							}else if(uniGPos.Count == 2){
								if (uniGPos [0].x > uniGPos [1].x) {	//change dimension
									Vector3 temp = uniGPos [0];
									uniGPos [0] = uniGPos [1];
									uniGPos [1] = temp;
								}
								
								bool sameType = legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getType () == legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getType () &&
									legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getType () == legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getType ();
								
								bool sameColor = legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getColor () == legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getColor () &&
									legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getColor () == legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getColor ();
								
								bool sameDimen = legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen().x == 1 &&
									legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getDimen ().x == 1 &&
										legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen().y == legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getDimen ().y;

								if (sameColor && sameType && sameDimen) {
									if (isValidLego (legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen (),
									                 legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getDimen (), true)) {//change dimension
										mergeTwoLegoHor (uniGPos [0], uniGPos [1]); //change dimension
										if (isValidLego (legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen (),
										                 legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getDimen (),
										                 legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen (), false)) {//change dimension
											mergeTwoLegoVert (gpos, ngpos); //change dimension
											mergeTwoLegoVert (gpos, uniGPos [0]); //change dimension
											isSuccess = true;
										}
									}
								}
							}

						}
					}
				}
			} else {
				if (legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].back.Count > 0) {	//change dimension
					Vector3 ngpos = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].back [0];	//change dimension
					if (legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getType () == legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getType () && 
					    legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getColor () == legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getColor ()) {
						//change dimension
						bool sameAxis = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getGPosition().x == legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getGPosition().x;
						//change dimension
						float resultDimen = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen ().y + legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getDimen ().y;
						if (resultDimen == 2.0f && sameAxis) {
							//change dimension
							if (isValidLego (legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen (), legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getDimen (), false)) {
								//gpos	ngpos
								mergeTwoLegoVert (gpos, ngpos); //change dimension
								isSuccess = true;
							}
						}
					}
				}
				
			}
			return isSuccess;
		}

		private bool mergeLeft(Vector3 gpos){
			bool isSuccess = false;
			if (legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen ().y == 1) {
				if (legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].left.Count > 0) {
					Vector3 ngpos = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].left [0];
					if (legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getType () == legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getType () && 
					    legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getColor () == legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getColor ()) {
						
						float resultDimen = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen ().x + legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getDimen ().x;
						if (resultDimen < 5.0f) {
							if (isValidLego (legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen (), legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getDimen (), true)) {
								//ngpos gpos
								mergeTwoLegoHor (ngpos, gpos);
								isSuccess = true;
							}
						} else {
							if (legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].left.Count > 0) {
								Vector3 nngpos = legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].left [0];
								if (legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getType () == legoGrid [(int)nngpos.x, (int)nngpos.y, (int)nngpos.z].getType () && 
								    legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getColor () == legoGrid [(int)nngpos.x, (int)nngpos.y, (int)nngpos.z].getColor ()) {
									if (isValidLego (legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen (), legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getDimen ()
									                 , legoGrid [(int)nngpos.x, (int)nngpos.y, (int)nngpos.z].getDimen (), true)) {
										//nngpos ngpos gpos 
										mergeTwoLegoHor (nngpos, ngpos);
										mergeTwoLegoHor (ngpos, gpos);
										isSuccess = true;
									}
								}
							}
						}
					}
				}
			} else if (legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen().y == 2) {
				bool keepgo = false;
				if (legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].left.Count > 0) {
					foreach (Vector3 ngposv in legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].left) {
						if (legoGrid [(int)ngposv.x, (int)ngposv.y, (int)ngposv.z].isVisted)
							legoGrid [(int)ngposv.x, (int)ngposv.y, (int)ngposv.z].isVisted = false;
					}
					List<Vector3> uniGPos = new List<Vector3> ();
					foreach (Vector3 ngposv in legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].left) {
						if (!legoGrid [(int)ngposv.x, (int)ngposv.y, (int)ngposv.z].isVisted) {
							legoGrid [(int)ngposv.x, (int)ngposv.y, (int)ngposv.z].isVisted = true;
							uniGPos.Add (legoGrid [(int)ngposv.x, (int)ngposv.y, (int)ngposv.z].getGPosition());
						}
					}
					if (uniGPos.Count == 1) {
						bool sameType =	legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getType () == legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getType ();
						bool sameColor = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getColor () == legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getColor ();
						bool sameAxis = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getGPosition().z == legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getGPosition().z;
						bool sameDimen = legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen().y == 2;
						if(sameType && sameColor && sameAxis && sameDimen){
							float resultDimen = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen ().x + legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen ().x;
							if (resultDimen < 5.0f || resultDimen == 6.0f || resultDimen == 8.0f) {
								if (isValidLego (legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen (), legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen (), true)) {
									//gpos	ngpos
									mergeTwoLegoHor (uniGPos[0], gpos);
									isSuccess = true;
								}
							}else if(resultDimen == 5.0f || resultDimen == 7.0f){
								keepgo = true;
							}
						}
					}else if (uniGPos.Count == 2) {
						if (uniGPos [0].z > uniGPos [1].z) {
							Vector3 temp = uniGPos [0];
							uniGPos [0] = uniGPos [1];
							uniGPos [1] = temp;
						}
						bool sameType = legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getType () == legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getType () &&
							legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getType () == legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getType ();
						
						bool sameColor = legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getColor () == legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getColor () &&
							legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getColor () == legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getColor ();
						
						bool sameDimen = legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen().y == 1 &&
							legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getDimen ().y == 1 &&
								legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen().x == legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getDimen ().x;
						
						if (sameColor && sameType && sameDimen) {
							if (isValidLego (legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen (),
							                 legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getDimen (), false)) {
								mergeTwoLegoVert (uniGPos [0], uniGPos [1]);
								float resultDimen = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen ().x + legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getDimen ().x;
								if (resultDimen < 5.0f || resultDimen == 6.0f || resultDimen == 8.0f) {
									if (isValidLego (legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen (),
									                 legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen (), true)) {
										mergeTwoLegoHor (uniGPos [0], gpos);
										isSuccess = true;
									}
								}else if(resultDimen == 5.0f || resultDimen == 7.0f){
									keepgo = true;
								}
							}
						}
					}
					
					if(!isSuccess && keepgo){
						Vector3 ngpos = uniGPos[0];
						if (legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].left.Count > 0) {
							foreach (Vector3 nngpos in legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].left) {
								if (legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].isVisted)
									legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].isVisted = false;
							}
							uniGPos.Clear();
							foreach (Vector3 nngpos in legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].left) {
								if (!legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].isVisted) {
									legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].isVisted = true;
									uniGPos.Add (new Vector3 (ngpos.x,ngpos.y,ngpos.z));
								}
							}
							
							if (uniGPos.Count == 1) {
								bool sameType =	legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getType () == legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getType ();
								bool sameColor = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getColor () == legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getColor ();
								bool sameAxis = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getGPosition().z == legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getGPosition().z;
								bool sameDimen = legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen().y == 2;
								if(sameType && sameColor && sameAxis && sameDimen){
									if (isValidLego (legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen (), legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen (), true)) {
										//ngpos gpos
										mergeTwoLegoHor (uniGPos[0], ngpos);
										mergeTwoLegoHor (uniGPos[0], gpos);
										isSuccess = true;
									}
								}
							}else if(uniGPos.Count == 2){
								if (uniGPos [0].z > uniGPos [1].z) {
									Vector3 temp = uniGPos [0];
									uniGPos [0] = uniGPos [1];
									uniGPos [1] = temp;
								}
								
								bool sameType = legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getType () == legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getType () &&
									legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getType () == legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getType ();
								
								bool sameColor = legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getColor () == legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getColor () &&
									legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getColor () == legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getColor ();
								
								bool sameDimen = legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen().y == 1 &&
									legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getDimen ().y == 1 &&
										legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen().x == legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getDimen ().x;
								
								if (sameColor && sameType && sameDimen) {
									if (isValidLego (legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen (),
									                 legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getDimen (), false)) {
										mergeTwoLegoVert (uniGPos [0], uniGPos [1]);
										if (isValidLego (legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen (),
										                 legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getDimen (),
										                 legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen (), true)) {
											mergeTwoLegoHor (uniGPos [0], ngpos);
											mergeTwoLegoHor (uniGPos [0], gpos);
											isSuccess = true;
										}
									}
								}
							}
							
						}
					}
				}
			} else {
				if (legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].left.Count > 0) {
					Vector3 ngpos = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].left [0];
					if (legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getType () == legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getType () && 
					    legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getColor () == legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getColor ()) {
						bool sameAxis = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getGPosition().z == legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getGPosition().z;
						float resultDimen = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen ().x + legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getDimen ().x;
						if (resultDimen == 2.0f && sameAxis) {
							if (isValidLego (legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen (), legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getDimen (), true)) {
								//gpos	ngpos
								mergeTwoLegoHor (ngpos, gpos);
								isSuccess = true;
							}
						}
					}
				}
			}
			return isSuccess;
		}

		private bool mergeRight(Vector3 gpos){
			bool isSuccess = false;
			if (legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen ().y == 1) {
				if (legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].right.Count > 0) {
					Vector3 ngpos = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].right [0];
					if (legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getType () == legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getType () && 
						legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getColor () == legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getColor ()) {

						float resultDimen = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen ().x + legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getDimen ().x;
						if (resultDimen < 5.0f) {
							if (isValidLego (legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen (), legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getDimen (), true)) {
								//gpos	ngpos
								mergeTwoLegoHor (gpos, ngpos);
								isSuccess = true;
							}
						} else {
							if (legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].right.Count > 0) {
								Vector3 nngpos = legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].right [0];
								if (legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getType () == legoGrid [(int)nngpos.x, (int)nngpos.y, (int)nngpos.z].getType () && 
									legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getColor () == legoGrid [(int)nngpos.x, (int)nngpos.y, (int)nngpos.z].getColor ()) {
									if (isValidLego (legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen (), legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getDimen ()
									               , legoGrid [(int)nngpos.x, (int)nngpos.y, (int)nngpos.z].getDimen (), true)) {
										//gpos ngpos nngpos
										mergeTwoLegoHor (gpos, ngpos);
										mergeTwoLegoHor (gpos, nngpos);
										isSuccess = true;
									}
								}
							}
						}
					}
				}
			} else if (legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen().y == 2) {
				bool keepgo = false;
				if (legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].right.Count > 0) {
					foreach (Vector3 ngposv in legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].right) {
						if (legoGrid [(int)ngposv.x, (int)ngposv.y, (int)ngposv.z].isVisted)
							legoGrid [(int)ngposv.x, (int)ngposv.y, (int)ngposv.z].isVisted = false;
					}
					List<Vector3> uniGPos = new List<Vector3> ();
					foreach (Vector3 ngposv in legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].right) {
						if (!legoGrid [(int)ngposv.x, (int)ngposv.y, (int)ngposv.z].isVisted) {
							legoGrid [(int)ngposv.x, (int)ngposv.y, (int)ngposv.z].isVisted = true;
							uniGPos.Add (legoGrid [(int)ngposv.x, (int)ngposv.y, (int)ngposv.z].getGPosition());
						}
					}
					if (uniGPos.Count == 1) {
						bool sameType =	legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getType () == legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getType ();
						bool sameColor = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getColor () == legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getColor ();
						bool sameAxis = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getGPosition().z == legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getGPosition().z;
						bool sameDimen = legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen().y == 2;
						if(sameType && sameColor && sameAxis && sameDimen){
							float resultDimen = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen ().x + legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen ().x;
							if (resultDimen < 5.0f || resultDimen == 6.0f || resultDimen == 8.0f) {
								if (isValidLego (legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen (), legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen (), true)) {
									//gpos	ngpos
									mergeTwoLegoHor (gpos, uniGPos[0]);
									isSuccess = true;
								}
							}else if(resultDimen == 5.0f || resultDimen == 7.0f){
								keepgo = true;
							}
						}
					}else if (uniGPos.Count == 2) {
						if (uniGPos [0].z > uniGPos [1].z) {
							Vector3 temp = uniGPos [0];
							uniGPos [0] = uniGPos [1];
							uniGPos [1] = temp;
						}
						bool sameType = legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getType () == legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getType () &&
							legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getType () == legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getType ();

						bool sameColor = legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getColor () == legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getColor () &&
							legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getColor () == legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getColor ();

						bool sameDimen = legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen().y == 1 &&
							legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getDimen ().y == 1 &&
								legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen().x == legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getDimen ().x;

						if (sameColor && sameType && sameDimen) {
							if (isValidLego (legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen (),
							                 legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getDimen (), false)) {
								mergeTwoLegoVert (uniGPos [0], uniGPos [1]);
								float resultDimen = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen ().x + legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getDimen ().x;
								if (resultDimen < 5.0f || resultDimen == 6.0f || resultDimen == 8.0f) {
									if (isValidLego (legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen (),
									               legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen (), true)) {
										mergeTwoLegoHor (gpos, uniGPos [0]);
										isSuccess = true;
									}
								}else if(resultDimen == 5.0f || resultDimen == 7.0f){
									keepgo = true;
								}
							}
						}
					}

					if(!isSuccess && keepgo){
						Vector3 ngpos = uniGPos[0];
						if (legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].right.Count > 0) {
							foreach (Vector3 nngpos in legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].right) {
								if (legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].isVisted)
									legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].isVisted = false;
							}
							uniGPos.Clear();
							foreach (Vector3 nngpos in legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].right) {
								if (!legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].isVisted) {
									legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].isVisted = true;
									uniGPos.Add (new Vector3 (ngpos.x,ngpos.y,ngpos.z));
								}
							}

							if (uniGPos.Count == 1) {
								bool sameType =	legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getType () == legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getType ();
								bool sameColor = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getColor () == legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getColor ();
								bool sameAxis = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getGPosition().z == legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getGPosition().z;
								bool sameDimen = legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen().y == 2;
								if(sameType && sameColor && sameAxis && sameDimen){
									if (isValidLego (legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen (), legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen (), true)) {
										//gpos	ngpos
										mergeTwoLegoHor (gpos, ngpos);
										mergeTwoLegoHor (gpos, uniGPos[0]);
										isSuccess = true;
									}
								}
							}else if(uniGPos.Count == 2){
								if (uniGPos [0].z > uniGPos [1].z) {
									Vector3 temp = uniGPos [0];
									uniGPos [0] = uniGPos [1];
									uniGPos [1] = temp;
								}
								
								bool sameType = legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getType () == legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getType () &&
									legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getType () == legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getType ();
								
								bool sameColor = legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getColor () == legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getColor () &&
									legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getColor () == legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getColor ();
								
								bool sameDimen = legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen().y == 1 &&
									legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getDimen ().y == 1 &&
										legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen().x == legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getDimen ().x;
								
								if (sameColor && sameType && sameDimen) {
									if (isValidLego (legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen (),
									                 legoGrid [(int)uniGPos [1].x, (int)uniGPos [1].y, (int)uniGPos [1].z].getDimen (), false)) {
										mergeTwoLegoVert (uniGPos [0], uniGPos [1]);
										if (isValidLego (legoGrid [(int)uniGPos [0].x, (int)uniGPos [0].y, (int)uniGPos [0].z].getDimen (),
										                 legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getDimen (),
										                 legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen (), true)) {
											mergeTwoLegoHor (gpos, ngpos);
											mergeTwoLegoHor (gpos, uniGPos [0]);
											isSuccess = true;
										}
									}
								}
							}

						}
					}
				}
			} else {
				if (legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].right.Count > 0) {
					Vector3 ngpos = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].right [0];
					if (legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getType () == legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getType () && 
					    legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getColor () == legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getColor ()) {
						bool sameAxis = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getGPosition().z == legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getGPosition().z;
						float resultDimen = legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen ().x + legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getDimen ().x;
						if (resultDimen == 2.0f && sameAxis) {
							if (isValidLego (legoGrid [(int)gpos.x, (int)gpos.y, (int)gpos.z].getDimen (), legoGrid [(int)ngpos.x, (int)ngpos.y, (int)ngpos.z].getDimen (), true)) {
								//gpos	ngpos
								mergeTwoLegoHor (gpos, ngpos);
								isSuccess = true;
							}
						}
					}
				}
			}
			return isSuccess;
		}

		private bool mergeToBrick(Vector3 pos){
			int x = (int)pos.x;
			int y = (int)pos.y;
			int z = (int)pos.z;
			Lego cur = legoGrid [x, y, z];
			List<Vector3> unique = new List<Vector3>();

			if (cur.up.Count == 0)
				return false;
			foreach (Vector3 fpos in cur.up)
				legoGrid [(int)fpos.x, (int)fpos.y, (int)fpos.z].isVisted = false;
			foreach (Vector3 fpos in cur.up) {
				if(!legoGrid [(int)fpos.x, (int)fpos.y, (int)fpos.z].isVisted){
					unique.Add(fpos);
				}
			}
			if (unique.Count != 1)
				return false;


			Lego nei = legoGrid [(int)unique[0].x, (int)unique[0].y, (int)unique[0].z];
			if (nei.up.Count == 0)
				return false;
			foreach (Vector3 fpos in nei.up)
				legoGrid [(int)fpos.x, (int)fpos.y, (int)fpos.z].isVisted = false;
			foreach (Vector3 fpos in nei.up) {
				if(!legoGrid [(int)fpos.x, (int)fpos.y, (int)fpos.z].isVisted){
					unique.Add(fpos);
				}
			}
			if (unique.Count != 2)
				return false;

			Vector3 up1 = unique [0];
			Vector3 up2 = unique [1];
			if (legoGrid [(int)up1.x, (int)up1.y, (int)up1.z].getGPosition ().x != legoGrid [(int)up2.x, (int)up2.y, (int)up2.z].getGPosition ().x ||
				legoGrid [(int)up1.x, (int)up1.y, (int)up1.z].getGPosition ().z != legoGrid [(int)up2.x, (int)up2.y, (int)up2.z].getGPosition ().z ||
				legoGrid [(int)up1.x, (int)up1.y, (int)up1.z].getGPosition ().x != legoGrid [x, y, z].getGPosition ().x ||
				legoGrid [(int)up1.x, (int)up1.y, (int)up1.z].getGPosition ().z != legoGrid [x, y, z].getGPosition ().z)
				return false;

			if (legoGrid [(int)up1.x, (int)up1.y, (int)up1.z].getDimen() != legoGrid [(int)up2.x, (int)up2.y, (int)up2.z].getDimen() ||
			    legoGrid [(int)up1.x, (int)up1.y, (int)up1.z].getDimen () != legoGrid [x, y, z].getDimen ())
				return false;

			if (legoGrid [(int)up1.x, (int)up1.y, (int)up1.z].getType() != LegoType.PLATE ||
			    legoGrid [(int)up2.x, (int)up2.y, (int)up2.z].getType() != LegoType.PLATE||
			    legoGrid [x,y,z].getType () != LegoType.PLATE)
				return false;

			/*merge to brick*/
			if(legoGrid[x,y,z].getColor() == legoGrid[(int)up1.x, (int)up1.y, (int)up1.z].getColor() && legoGrid[x,y,z].getColor() == legoGrid[(int)up2.x, (int)up2.y, (int)up2.z].getColor()){
				mergePlatesToBrick(ref legoGrid[(int)up2.x, (int)up2.y, (int)up2.z],ref legoGrid[(int)up1.x, (int)up1.y, (int)up1.z], ref legoGrid[x,y,z]);
				return true;
			}
			return false;
		}

		private bool isBoundEngaged(Lego target){
			if (target.up.Count > 0 && target.down.Count > 0)
				return true;
			foreach (Vector3 gpos in target.gposList) {
				if (!grids [(int)gpos.x, (int)gpos.y, (int)gpos.z].isBound) {
					return true;
				}
			}
			foreach (Vector3 gpos in target.up) {
				if (!grids [(int)gpos.x, (int)gpos.y, (int)gpos.z].isBound) {
					return true;
				}
			}
			foreach (Vector3 gpos in target.down) {
				if (!grids [(int)gpos.x, (int)gpos.y, (int)gpos.z].isBound) {
					return true;
				}
			}
			return false;
		}

		private void propageFromBound (List<Vector3> bounds, int level){
			if(level % 2 == 0) {
				bool isSceure = false;
				foreach (Vector3 pos in bounds) {
					Lego target = legoGrid [(int)pos.x, (int)pos.y, (int)pos.z];
					if(target.getDimen() != new Vector2(1,1))
						continue;
					bool flag = true;
					while(flag){
						flag = mergeFront(pos);
						flag = flag || mergeBack(pos);
					}

					target = legoGrid [(int)pos.x, (int)pos.y, (int)pos.z];
					isSceure = isBoundEngaged(target);

					if (!isSceure) {
						flag = true;
						resetLego (pos);
						while(flag){
							flag = mergeLeft(pos);
							flag = flag || mergeRight(pos);
						}
					}
				}
			}else{
				bool isSceure = false;
				foreach(Vector3 pos in bounds){
					Lego target = legoGrid[(int)pos.x,(int)pos.y,(int)pos.z];
					if(target.getDimen() != new Vector2(1,1))
						continue;

					bool flag = true;
					while(flag){
						flag = mergeLeft(pos);
						flag = flag || mergeRight(pos);
					}

					target = legoGrid[(int)pos.x,(int)pos.y,(int)pos.z];
					isSceure = isBoundEngaged(target);

					if(!isSceure){
						flag = true;
						resetLego(pos);

						while(flag){
							flag = mergeFront(pos);
							flag = flag || mergeBack(pos);
						}
					}
				}
			}
		}

		/*------------------------------------------------merge lego---------------------------*/
		public IEnumerator Legoize(Grid[,,] grids , Vector3 dimen, float gridsize){ //grids, totalx, totaly,totalz, gridsize
			transform.localScale = new Vector3(1.0f,1.0f,1.0f);
			this.grids = grids;
			inLegoize = true;
			legoGridDimen = dimen;
			int counter = 0;
			legosCoordinate = new Dictionary<ColorSpecification, List<Lego>>();
			legos = new List<Lego> ();
			legoGrid  = new Lego[(int)dimen.x, (int)dimen.y, (int)dimen.z];
			percentage = 0;
			onLoading = true;

			GameObject target = GameObject.Find ("Target");
			OBJ obj = target.GetComponent<OBJ> ();

			int stepCounter = 0;
			LoadingText.GetComponent<Text> ().text = "Legoization \n preprocessing...";
			yield return new WaitForFixedUpdate();

			/*fill lego grid base on voxel grid result*/
			for (int y =0; y < dimen.y; y++) {
				for (int x = 0; x < dimen.x; x++) {
					for (int z = 0; z < dimen.z; z++) {
						if(grids[x,y,z] != null){
							legoGrid[x,y,z] = new Lego(grids[x,y,z].nearestColor(),grids[x,y,z].getPosition(),LegoType.PLATE,grids[x,y,z].isBound);
							legoGrid[x,y,z].setGPos(new Vector3(x,y,z));
							legoGrid[x,y,z].gposList.Add(new Vector3(x,y,z));
						}
					}
				}
				stepCounter++;
				if (stepCounter > 25){
					stepCounter = 0;
					//precentage update
					percentage = (y) / (dimen.y * 2);
					yield return new WaitForFixedUpdate ();
				}
			}

			for (int y =0; y < dimen.y; y++) {
				for (int x = 0; x < dimen.x; x++) {
					for (int z = 0; z < dimen.z; z++) {
						if(legoGrid[x,y,z] != null){
							if (x - 1 >= 0 && legoGrid [x - 1, y, z] != null)
								legoGrid [x, y, z].left.Add (new Vector3(x - 1, y, z));
							if (x + 1 < legoGridDimen.x && legoGrid [x + 1, y, z] != null)
								legoGrid [x, y, z].right.Add (new Vector3(x + 1, y, z));
							
							if (y + 1 < legoGridDimen.y && legoGrid [x, y + 1, z] != null)
								legoGrid [x, y, z].up.Add (new Vector3(x, y + 1, z));
							if (y - 1 >= 0 && legoGrid [x, y - 1, z] != null)
								legoGrid [x, y, z].down.Add (new Vector3(x, y - 1, z));
							
							if (z + 1 < legoGridDimen.z && legoGrid [x, y, z + 1] != null)
								legoGrid [x, y, z].back.Add (new Vector3(x, y, z + 1));
							if (z - 1 >= 0 && legoGrid [x, y, z - 1] != null)
								legoGrid [x, y, z].front.Add (new Vector3(x, y, z - 1));
						}
					}
				}
				stepCounter++;
				if (stepCounter > 25){
					stepCounter = 0;
					//precentage update
					percentage = (dimen.y+y) / (dimen.y * 2);
					yield return new WaitForFixedUpdate ();
				}
			}

			yield return new WaitForFixedUpdate();
			/*--------- Merge Algorithm ----------*/
			Debug.Log(onLoading);
			stepCounter = 0;
			LoadingText.GetComponent<Text> ().text = "Leogization \n Pass 1/3...";
			List<Vector3> positions = new List<Vector3> ();
			List<Vector3> bounds = new List<Vector3> ();
			List<Vector3> urgent = new List<Vector3> ();
			for (int y =0; y < dimen.y; y++) {
				for (int x = 0; x < dimen.x; x++) {
					for (int z = 0; z < dimen.z; z++) {
						if (legoGrid [x, y, z] != null && legoGrid [x, y, z].getGPosition ().y == y) {
							if (legoGrid [x, y, z].up.Count == 0 && legoGrid [x, y, z].down.Count == 0)
								urgent.Add (new Vector3 (x, y, z));
							else if (grids [x, y, z].isBound)
								bounds.Add (new Vector3 (x, y, z));
						}
					}
				}
				propageFromBound (urgent, y);
				propageFromBound (bounds, y);
				urgent.Clear ();
				bounds.Clear ();

				stepCounter++;
				if (stepCounter > 25){
				//precentage update
					stepCounter = 0;
					percentage = y / (dimen.y * 2);
					yield return new WaitForFixedUpdate ();
				}
			}

			stepCounter = 0;
			for (int y =0; y < dimen.y ; y+=3) {
				for(int x = 0; x < dimen.x; x++){
					for(int z = 0; z < dimen.z; z++){
						if(legoGrid[x,y,z]!=null && legoGrid[x,y,z].getGPosition().y == y){
							positions.Add(new Vector3(x,y,z));
						}
					}
				}

				foreach(Vector3 pos in positions){
					mergeToBrick(pos);
				}

				stepCounter++;
				if (stepCounter > 25){
					//precentage update
					stepCounter = 0;
					percentage = (dimen.y+y) / (dimen.y * 2);
					yield return new WaitForFixedUpdate ();
				}
				positions.Clear ();
			}

			counter = 0;
			Debug.Log(onLoading);
			yield return new WaitForFixedUpdate();
			LoadingText.GetComponent<Text> ().text = "Leogization \n Pass 2/3...";
			percentage = 0;
			stepCounter = 0;

			for (int y =0; y < dimen.y ; y++) {
				for(int x = 0; x < dimen.x; x++){
					for(int z = 0; z < dimen.z; z++){
						if(legoGrid[x,y,z]!=null && legoGrid[x,y,z].getGPosition().y == y){
							positions.Add(new Vector3(x,y,z));
						}
					}
				}

				foreach(Vector3 pos in positions){
					bool flag = true;
					if(y%2 == 0){
						while(flag){
							flag = mergeFront(pos);
							flag = flag || mergeBack(pos);
						}
					}else{
						while(flag){
							flag = mergeLeft(pos);
							flag = flag || mergeRight(pos);
						}
					}

				}

				stepCounter++;
				if (stepCounter > 25){
					//precentage update
					stepCounter = 0;
					percentage = y / dimen.y;
					yield return new WaitForFixedUpdate ();
				}
				positions.Clear ();
			}

			Debug.Log(onLoading);
			yield return new WaitForFixedUpdate();
			LoadingText.GetComponent<Text> ().text = "Leogization \n Pass 3/3...";
			percentage = 0;
			stepCounter = 0;

			for (int y =0; y < dimen.y ; y++) {
				for(int x = 0; x < dimen.x; x++){
					for(int z = 0; z < dimen.z; z++){
						if(legoGrid[x,y,z]!=null && legoGrid[x,y,z].getGPosition().y == y)
							positions.Add(new Vector3(x,y,z));
					}
				}
				foreach(Vector3 pos in positions){
					List<Lego> tempLegoList = new List<Lego>();
					int initialNum = 0;
					Lego curLego = legoGrid[(int)pos.x,(int)pos.y,(int)pos.z];
					Vector3 nextVec;
					Lego nextLego;
					tempLegoList.Add(curLego);
					initialNum = numOfLegoConnected(tempLegoList);
					int numberContainer = initialNum;
					if(y%2 == 0){
						if(curLego.left.Count == 1){
							nextVec = curLego.left[0];
							nextLego = legoGrid[(int)nextVec.x,(int)nextVec.y,(int)nextVec.z];
							tempLegoList.Add(nextLego);
							numberContainer = numOfLegoConnected(tempLegoList);
							tempLegoList.Remove(nextLego);
						}
						if(curLego.right.Count == 1){
							nextVec = curLego.right[0];
							nextLego = legoGrid[(int)nextVec.x,(int)nextVec.y,(int)nextVec.z];
							tempLegoList.Add(nextLego);
						}

						if(numOfLegoConnected(tempLegoList) > numberContainer){
							while(mergeRight(pos));
						}else if(numberContainer > initialNum){
							while(mergeLeft(pos));
						}

					}else{
						if(curLego.front.Count == 1){
							nextVec = curLego.front[0];
							nextLego = legoGrid[(int)nextVec.x,(int)nextVec.y,(int)nextVec.z];
							tempLegoList.Add(nextLego);
							numberContainer = numOfLegoConnected(tempLegoList);
							tempLegoList.Remove(nextLego);
						}
						if(curLego.back.Count == 1){
							nextVec = curLego.back[0];
							nextLego = legoGrid[(int)nextVec.x,(int)nextVec.y,(int)nextVec.z];
							tempLegoList.Add(nextLego);
						}

						if(numOfLegoConnected(tempLegoList) > numberContainer){
							while(mergeBack(pos));
						}else if(numberContainer > initialNum){
							while(mergeFront(pos));
						}

					}
					tempLegoList.Clear();
				}
				yield return new WaitForFixedUpdate();

				foreach(Vector3 pos in positions){
					bool flag = true;
					if(y%2 == 1){
						while(flag){
							flag = mergeFront(pos);
							flag = flag || mergeBack(pos);
						}
					}else{
						while(flag){
							flag = mergeLeft(pos);
							flag = flag || mergeRight(pos);
						}
					}
					
				}

				stepCounter++;
				if (stepCounter > 25){
					//precentage update
					stepCounter = 0;
					percentage = (y) / (dimen.y * 2);
					yield return new WaitForFixedUpdate ();
				}
				positions.Clear();
			}

			
			for (int y =0; y < dimen.y ; y++) {
				for(int x = 0; x < dimen.x; x++){
					for(int z = 0; z < dimen.z; z++){
						if(legoGrid[x,y,z]!=null && legoGrid[x,y,z].getGPosition().y == y){
							mergeToBrick(new Vector3(x,y,z));
						}
					}
				}
				stepCounter++;
				if (stepCounter > 25){
					//precentage update
					stepCounter = 0;
					percentage = (dimen.y + y) / (dimen.y * 2);
					yield return new WaitForFixedUpdate ();
				}
			}
			yield return new WaitForFixedUpdate();
			legos.Clear ();
			/*----render result----*/

			for (int c= 0; c < (int)ColorSpecification.NUM_OF_COLOR; c++){
				legosCoordinate.Add((ColorSpecification)c,new List<Lego>());
			}

			foreach (Lego lego in legoGrid) {
				if(lego != null)
					lego.isVisted = false;
			}

			yield return new WaitForFixedUpdate();

			//Debug.Log (counter);
			//counter = 0;
		
			foreach(Lego lego in legoGrid){
				if(lego != null && !lego.isVisted){
					if(lego.up.Count ==0 && lego.down.Count==0){
						//legosCoordinate[ColorSpecification.BLUE].Add(lego);
						//lego.changeColor(ColorSpecification.BLUE);
						legosCoordinate[lego.getColor()].Add(lego);
						lego.isVisted = true;
						counter++;
					}else{
						legosCoordinate[lego.getColor()].Add(lego);
						lego.isVisted = true;
					}
				}
			}

			Debug.Log ("unconnected Lego:" + counter);
			counter = 0;

			int max_vertice_gameObject = 2500;
			buffer = new LegoBuffer();
		
			for (int c= 0; c < (int)ColorSpecification.NUM_OF_COLOR; c++){
				
				List<Lego> coor = legosCoordinate[(ColorSpecification)c];
				legos.AddRange(coor);
				counter+=coor.Count;
				if(coor.Count>0){
					List<GameObject> gos = new List<GameObject>();
					int index = 0;
					Color color;
					color = Grid.getColor((ColorSpecification)c);
					for(int i = coor.Count ; i > 0; i-=max_vertice_gameObject){
						GameObject go = new GameObject();
						go.transform.parent = gameObject.transform;
						go.AddComponent(typeof(MeshFilter));
						go.AddComponent(typeof(MeshRenderer));
						gos.Add(go);
					}
					
					for(int i =0; i < gos.Count; i++){
						int count_coor = (coor.Count - i*max_vertice_gameObject >=max_vertice_gameObject)? max_vertice_gameObject : coor.Count - i*max_vertice_gameObject;
						buffer.draw(gos[i],coor.GetRange(i*max_vertice_gameObject,count_coor),gridsize,color);
						index++;
					}
					gos.Clear();
				}
			}
			Debug.Log (counter);

			//LxfmlWriter xmlWriter = new LxfmlWriter();
			//StartCoroutine(xmlWriter.writeXML(legos));

			System.GC.Collect();
			Resources.UnloadUnusedAssets();
			obj.onProcessing = false;
			obj.legos = legos;
			obj.hasLegoized = true;
			onLoading = false;

			transform.localScale = new Vector3(-1.0f,1.0f,1.0f);

			yield return new WaitForFixedUpdate();

			inLegoize = false;
			Debug.Log ("End of Legoization with UI");
			yield return new WaitForSeconds(0.0f);
		}
	}
}