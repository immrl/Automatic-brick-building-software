//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;
using System.Collections.Generic;


namespace AssemblyCSharp
{
	public enum ColorSpecification{
		BLACK, 		//25,39,48
		WHITE, 		//226,226,226
		RED, 		//167,0,0
		LIGHT_GRAY,	//139,139,139	
		DARK_GRAY,	//109 110 108
		YELLOW,		//93,93,93
		BLUE,		//28,83,156
		GREEN,		//0,66,21
		BROWN,		//88,45,8
		NUM_OF_COLOR
	}

	public class Grid
	{	
		static Vector3[] colorsControl = {
			new Vector3 (25,39,48),
			new Vector3 (226,226,226),
			new Vector3 (167,0,0),
			new Vector3 (139,139,139),
			new Vector3 (93,93,93),
			new Vector3 (232,186,9),
			new Vector3 (28,83,156),
			new Vector3 (0,66,21),
			new Vector3 (88,45,8)
		};

		float x,y,z;
		int gx,gy,gz;
		List<Vector3> pts;
		Vector3 normals;
		public Color color;
		float min_diff;
		int color_count;
		public bool isBound;

		public Grid (float x, float y, float z)
		{
			this.x = x;
			this.y = y;
			this.z = z;
			pts = new List<Vector3> ();
			color = new Color (0, 0, 0, 1);
			color_count = 0;
			min_diff = float.MaxValue;
			isBound = true;
		}

		public Grid (float x, float y, float z, bool isBound)
		{
			this.x = x;
			this.y = y;
			this.z = z;
			pts = new List<Vector3> ();
			color = new Color (0, 0, 0, 1);
			color_count = 0;
			min_diff = float.MaxValue;
			this.isBound = isBound;
		}

		private void addNoraml(Vector3 normal){
			int totalNor = pts.Count;
			normals = (normals * totalNor + normal)/(totalNor+1);
		}

		public Vector3 getNoraml(){
			return normals;
		}

		public void setGPosition(int x, int y, int z){
			gx = x;
			gy = y;
			gz = z;
		}

		public bool isEmpty(){
			return (pts.Count < 1);
		}

		public void addPoint(Vector3 pt, Vector3 normal){
			pts.Add (pt);
			addNoraml (normal);
		}

		public Vector3 getPosition(){
			return new Vector3(x,y,z);
		}

		public Vector3 getLPosition(){
			float lx = (float)gx;
			float ly = (float)gy;
			float lz = (float)gz;
			return new Vector3(lx*0.8f+0.4f,ly*0.32f,lz*0.8f+0.4f);
		}

		public void AddColor(Color color){
			this.color = color;
		}

		public void AddColor(Vector3 pos, Color color){
			if (OBJ.colorMode == 0) {
				///*
				Vector3 thisPos = new Vector3 (x, y, z);
				float dist_diff = Mathf.Abs (Vector3.Distance (thisPos, pos));
				if (dist_diff < min_diff) {
					min_diff = dist_diff;
					this.color = color;
				}
				//*/
			} else {
				///*average color
				this.color = this.color * color_count + color;
				color_count++;
				this.color /= color_count;
				//*/
			}
		}

		public Color getColor(){
			Vector3 cv = colorsControl [(int)nearestColor()];
			return new Color(cv.x/255.0f,cv.y/255.0f,cv.z/255.0f,1);
		}

		public static Color getColor(ColorSpecification index){
			Vector3 cv = colorsControl [(int)index];
			return new Color(cv.x/255.0f,cv.y/255.0f,cv.z/255.0f,1);
		}

		public ColorSpecification nearestColor(){
			Vector3 tempColor = new Vector3 (color.r*255, color.g*255, color.b*255);
			float min_dist = float.MaxValue;
			ColorSpecification result = ColorSpecification.BLACK;
			int i = 0;
			foreach (Vector3 cvector in colorsControl) {
				float temp_dis = Vector3.Distance(cvector,tempColor);
				if(temp_dis < min_dist){
					min_dist = temp_dis;
					result = (ColorSpecification)i;
				}
				i++;
			}
			return result;
		}

		private void addNearestColor(Color color){
			Vector3 tempColor = new Vector3 (color.r*255, color.g*255, color.b*255);
			float min_dist = min_diff;
			int i = 0;
			foreach (Vector3 cvector in colorsControl) {
				float temp_dis = Vector3.Distance(cvector,tempColor);
				if(temp_dis < min_dist){
					min_dist = temp_dis;
				}
				i++;
			}

			if (min_dist < min_diff) {
				this.color = color;
				min_diff = min_dist;
			}
		}
	}
}

